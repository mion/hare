(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Cell, Creature, Grid, Movement, Position, Simulation, _above, _alignX, _centerize, _centerizedPoint, _middleX, _middleY, clusterMaker, simulation,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  clusterMaker = require("clusters");

  Position = require('./position');

  Movement = require('./movement');

  _centerize = function(overLayer, underLayer) {
    var paddingX, paddingY;
    paddingX = (underLayer.width - overLayer.width) / 2;
    paddingY = (underLayer.height - overLayer.height) / 2;
    overLayer.x = underLayer.x + paddingX;
    return overLayer.y = underLayer.y + paddingY;
  };

  _centerizedPoint = function(overLayer, underLayer) {
    var paddingX, paddingY;
    paddingX = (underLayer.width - overLayer.width) / 2;
    paddingY = (underLayer.height - overLayer.height) / 2;
    return {
      x: underLayer.x + paddingX,
      y: underLayer.y + paddingY
    };
  };

  _middleY = function(layer) {
    return layer.y + layer.height / 2;
  };

  _middleX = function(layer) {
    return layer.x + layer.width / 2;
  };

  _alignX = function(layer, fixedLayer) {
    return layer.x = _middleX(fixedLayer.x) - layer.width / 2;
  };

  _above = function(layer, fixedLayer, margin) {
    return layer.y = fixedLayer.y - (_.isNil(margin) ? layer.height : margin);
  };

  Cell = (function(superClass) {
    extend(Cell, superClass);

    function Cell(parent, sqm, i, j, backgroundColor) {
      Cell.__super__.constructor.call(this, {
        parent: parent,
        x: i * sqm,
        y: i * sqm,
        width: sqm,
        height: sqm,
        backgroundColor: backgroundColor
      });
    }

    return Cell;

  })(Layer);

  Grid = (function(superClass) {
    extend(Grid, superClass);

    function Grid(sqm1) {
      var bgColor, cell, counter, i, j, k, l, ref, ref1;
      this.sqm = sqm1;
      Grid.__super__.constructor.call(this, {
        x: 0,
        y: 0,
        width: Canvas.width,
        height: Canvas.height,
        backgroundColor: '#333333'
      });
      this.rows = Math.ceil(this.height / this.sqm);
      this.columns = Math.ceil(this.width / this.sqm);
      this.cells = {};
      counter = 0;
      this.creatures = [];
      for (i = k = 0, ref = this.rows - 1; k <= ref; i = k += 1) {
        this.cells[i] = {};
        for (j = l = 0, ref1 = this.columns - 1; l <= ref1; j = l += 1) {
          this.cells[i][j] = null;
          bgColor = counter % 2 === 0 ? '#f0f0f0' : '#f6f6f6';
          counter += 1;
          cell = new Layer({
            parent: this,
            x: i * this.sqm,
            y: j * this.sqm,
            width: this.sqm,
            height: this.sqm,
            backgroundColor: bgColor
          });
          this.cells[i][j] = cell;
        }
      }
    }

    Grid.prototype.cellAt = function(pos) {
      return this.cells[pos.i][pos.j];
    };

    Grid.prototype.isWithinBounds = function(pos) {
      return (0 <= pos.i) && (pos.i <= (this.rows - 1)) && (0 <= pos.j) && (pos.j <= (this.columns - 1));
    };

    Grid.prototype.addCreature = function(creature) {
      this.creatures.push(creature);
      this.addChild(creature);
      return _centerize(creature, this.cellAt(creature.pos));
    };

    Grid.prototype.isWalkable = function(pos) {
      return !_.some(this.creatures, function(creature) {
        return creature.pos.isEqual(pos);
      });
    };

    return Grid;

  })(Layer);

  Creature = (function(superClass) {
    extend(Creature, superClass);

    function Creature(displayName, pos1) {
      var healthBarLayer, nameTextLayer;
      this.displayName = displayName;
      this.pos = pos1;
      this.health = 100;
      this.energy = 100;
      this.hunger = 100;
      this.thirst = 100;
      this.sex = 100;
      this.pleasure = 100;
      Creature.__super__.constructor.call(this, {
        name: 'creature_' + this.displayName.toLowerCase().split(' ').join('_'),
        width: 50,
        height: 50,
        backgroundColor: '#0099ff',
        borderRadius: 12
      });
      nameTextLayer = new TextLayer({
        text: this.displayName,
        fontSize: 15,
        fontFamily: 'Arial',
        textAlign: 'center',
        x: this.x,
        y: this.y,
        width: this.width,
        color: '#000000'
      });
      this.addChild(nameTextLayer);
      healthBarLayer = new Layer({
        x: this.x,
        y: this.y,
        width: this.width,
        height: 5,
        backgroundColor: '#00ff00',
        borderWidth: 1,
        borderColor: '#000000'
      });
      this.addChild(healthBarLayer);
      _above(healthBarLayer, this, 10);
      _above(nameTextLayer, healthBarLayer, 20);
    }

    return Creature;

  })(Layer);

  Simulation = (function() {
    function Simulation() {
      this.grid = new Grid(70);
    }

    Simulation.prototype.start = function() {
      this.foo = new Creature("Foo", new Position(1, 2));
      this.grid.addCreature(this.foo);
      this.bar = new Creature("Bar", new Position(2, 2));
      this.grid.addCreature(this.bar);
      this.quux = new Creature("Quux", new Position(0, 2));
      return this.grid.addCreature(this.quux);
    };

    Simulation.prototype.update = function() {
      var action, dir;
      console.log('[*] Updating');
      dir = Utils.randomChoice(["up", "down", "left", "right"]);
      action = new Movement(this.grid, this.foo, this.foo.pos.next(dir));
      return action.perform();
    };

    return Simulation;

  })();

  simulation = new Simulation;

  simulation.start();

  Utils.interval(1, function() {
    return simulation.update();
  });

}).call(this);

},{"./movement":2,"./position":3,"clusters":5}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Position, __;

  Position = require('./position');

  __ = require('./utils');

  module.exports = (function() {
    function exports(grid, creature, targetPos) {
      this.grid = grid;
      this.creature = creature;
      this.targetPos = targetPos;
    }

    exports.prototype.isValid = function() {
      return this.grid.isWithinBounds(this.targetPos) && this.grid.isWalkable(this.targetPos);
    };

    exports.prototype.perform = function() {
      var anim;
      if (this.creature.isAnimating) {
        return false;
      }
      if (!this.isValid()) {
        return false;
      }
      anim = new Animation(this.creature, {
        point: __.centerizedPoint(this.creature, this.grid.cellAt(this.targetPos))
      });
      anim.start();
      anim.on(Events.AnimationEnd, (function(_this) {
        return function() {
          return _this.creature.pos = new Position(_this.targetPos.i, _this.targetPos.j);
        };
      })(this));
      return true;
    };

    return exports;

  })();

}).call(this);

},{"./position":3,"./utils":4}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  var Position;

  module.exports = Position = (function() {
    function Position(i, j) {
      this.i = i;
      this.j = j;
    }

    Position.prototype.isEqual = function(pos) {
      return this.i === pos.i && this.j === pos.j;
    };

    Position.prototype.next = function(direction) {
      if (direction === "up") {
        return new Position(this.i, this.j - 1);
      } else if (direction === "down") {
        return new Position(this.i, this.j + 1);
      } else if (direction === "left") {
        return new Position(this.i - 1, this.j);
      } else if (direction === "right") {
        return new Position(this.i + 1, this.j);
      } else {
        return null;
      }
    };

    return Position;

  })();

}).call(this);

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.12.6
(function() {
  module.exports = {
    centerize: function(overLayer, underLayer) {
      var paddingX, paddingY;
      paddingX = (underLayer.width - overLayer.width) / 2;
      paddingY = (underLayer.height - overLayer.height) / 2;
      overLayer.x = underLayer.x + paddingX;
      return overLayer.y = underLayer.y + paddingY;
    },
    centerizedPoint: function(overLayer, underLayer) {
      var paddingX, paddingY;
      paddingX = (underLayer.width - overLayer.width) / 2;
      paddingY = (underLayer.height - overLayer.height) / 2;
      return {
        x: underLayer.x + paddingX,
        y: underLayer.y + paddingY
      };
    },
    middleY: function(layer) {
      return layer.y + layer.height / 2;
    },
    middleX: function(layer) {
      return layer.x + layer.width / 2;
    },
    alignX: function(layer, fixedLayer) {
      return layer.x = _middleX(fixedLayer.x) - layer.width / 2;
    },
    above: function(layer, fixedLayer, margin) {
      return layer.y = fixedLayer.y - (_.isNil(margin) ? layer.height : margin);
    }
  };

}).call(this);

},{}],5:[function(require,module,exports){
'use strict'

module.exports = {

  data: getterSetter([], function(arrayOfArrays) {
    var n = arrayOfArrays[0].length;
    return (arrayOfArrays.map(function(array) {
      return array.length == n;
    }).reduce(function(boolA, boolB) { return (boolA & boolB) }, true));
  }),

  clusters: function() {
    var pointsAndCentroids = kmeans(this.data(), {k: this.k(), iterations: this.iterations() });
    var points = pointsAndCentroids.points;
    var centroids = pointsAndCentroids.centroids;

    return centroids.map(function(centroid) {
      return {
        centroid: centroid.location(),
        points: points.filter(function(point) { return point.label() == centroid.label() }).map(function(point) { return point.location() }),
      };
    });
  },

  k: getterSetter(undefined, function(value) { return ((value % 1 == 0) & (value > 0)) }),

  iterations: getterSetter(Math.pow(10, 3), function(value) { return ((value % 1 == 0) & (value > 0)) }),

};

function kmeans(data, config) {
  // default k
  var k = config.k || Math.round(Math.sqrt(data.length / 2));
  var iterations = config.iterations;

  // initialize point objects with data
  var points = data.map(function(vector) { return new Point(vector) });

  // intialize centroids randomly
  var centroids = [];
  for (var i = 0; i < k; i++) {
    centroids.push(new Centroid(points[i % points.length].location(), i));
  };

  // update labels and centroid locations until convergence
  for (var iter = 0; iter < iterations; iter++) {
    points.forEach(function(point) { point.updateLabel(centroids) });
    centroids.forEach(function(centroid) { centroid.updateLocation(points) });
  };

  // return points and centroids
  return {
    points: points,
    centroids: centroids
  };

};

// objects
function Point(location) {
  var self = this;
  this.location = getterSetter(location);
  this.label = getterSetter();
  this.updateLabel = function(centroids) {
    var distancesSquared = centroids.map(function(centroid) {
      return sumOfSquareDiffs(self.location(), centroid.location());
    });
    self.label(mindex(distancesSquared));
  };
};

function Centroid(initialLocation, label) {
  var self = this;
  this.location = getterSetter(initialLocation);
  this.label = getterSetter(label);
  this.updateLocation = function(points) {
    var pointsWithThisCentroid = points.filter(function(point) { return point.label() == self.label() });
    if (pointsWithThisCentroid.length > 0) self.location(averageLocation(pointsWithThisCentroid));
  };
};

// convenience functions
function getterSetter(initialValue, validator) {
  var thingToGetSet = initialValue;
  var isValid = validator || function(val) { return true };
  return function(newValue) {
    if (typeof newValue === 'undefined') return thingToGetSet;
    if (isValid(newValue)) thingToGetSet = newValue;
  };
};

function sumOfSquareDiffs(oneVector, anotherVector) {
  var squareDiffs = oneVector.map(function(component, i) {
    return Math.pow(component - anotherVector[i], 2);
  });
  return squareDiffs.reduce(function(a, b) { return a + b }, 0);
};

function mindex(array) {
  var min = array.reduce(function(a, b) {
    return Math.min(a, b);
  });
  return array.indexOf(min);
};

function sumVectors(a, b) {
  return a.map(function(val, i) { return val + b[i] });
};

function averageLocation(points) {
  var zeroVector = points[0].location().map(function() { return 0 });
  var locations = points.map(function(point) { return point.location() });
  var vectorSum = locations.reduce(function(a, b) { return sumVectors(a, b) }, zeroVector);
  return vectorSum.map(function(val) { return val / points.length });
};

},{}]},{},[1]);
